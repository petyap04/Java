Функционален интерфейс - интерфейс с един метод в себе си - пример Comparator<T> (с метод compare())
Маркерен интерфейс - празен интерфейс - пример Serializable – Класовете, които имплементират този интерфейс

Ковариантност: приемат се типове-наследници (subtypes) - масивите са ковариантни
Контравариантност: приемат се типове-родители (supertypes)

Ограничени generic типове
Може да се специфицира, че generic тип е съвместим само с даден тип или негови наследници/имплементации (upper bound). <T extends Integer>
Box<Integer> is-not-а Box<Number>. Техният общ родител е Object

Wildcards, ограничени отгоре - List<? extends Number> -  списък от Integer, Double, Float, Number - избираме най-общото
Wildcards, ограничени отдолу - List<? super Integer> - работи с колекции от Integer, Number, Object - избираме най-конкретното

Използвай extends wildcard, когато само ще get-ваш стойности от структура
Използвай super wildcard, когато само ще put-ваш стойности в структура
неограничени или ограничени отдолу – заместват се с java.lang.Object
ограничени отгоре – заместват се с техния ограничителен тип

Основни видове тестове - Ръчни и Автоматични - функционални и нефункционални

Функционални тестове
-unit тестове
-integration тестове
Нефункционални тестове
-performance тестове
-stress тестове
-crash тестове
-security тестове
-usability тестове

Един unit test цели да тества малък фрагмент код - обикновено един метод
testing frameworks - Улесняват ни да пишем и изпълняваме тестове
                   - Стандартизират разработката и поддръжката на тестове
JUnit се базира на анотации
Всеки JUnit тест е метод, анотиран с @Test, съдържащ се в клас, който се използва само за тестване
Такъв клас се нарича test case
JUnit анотации за жизнен цикъл: 
@BeforeEach - методът се изпълнява преди всеки тест
@AfterEach - методът се изпълнява след всеки тест
ако са статични ще се изпълнят по веднъж в началото и края на тестването - използваме ги за скъпи операции

с анотацията @TestMethodOrder на ниво клас, да определите реда на изпълнение на тестовите му методи. Например, чрез параметризираната анотацията @Order на всеки тест - НЕ Е ПРЕПОРЪЧИТЕЛНО ДА СЕ ПРАВИ

Може временно да изключваме/игнорираме даден тест с анотацията @Disabled

Stubbing
Stub наричаме клас, който отговаря на дадени извиквания на методи с предварително зададени отговори
Обикновено имплементират по минимален начин даден интерфейс и се подават на класа, който се тества
В unit тестването ни служат за справяне с проблема с композираните класове
Извън unit тестването, могат да бъдат използвани и като заместител на код, който още не е разработен

Mock наричаме обект, който програмно конфигурираме с дадени отговори на дадени извиквания на методи
Mock-овете ни позволяват лесно да се провери дали даден метод на mock-a е извикан и с какви аргументи е извикан
Инструмент, чрез който контролираме и изолираме композираните класове

try блок, който декларира един или повече ресурси и автоматично затваря всеки ресурс в края на блока
Ресурс може да е обект от произволен клас, който имплементира интерфейса java.lang.AutoCloseable (което включва всички класове, които имплементират java.io.Closeable)
Каквото е декларирано в кръглите скоби след try, се .close()-ва автоматично при излизане от try блока.

За да си гарантирате, че Java кодът ви ще работи коректно на всяка OS, вместо тези символи, трябва да ползвате - System.lineSeparator(), или
         - PrintWriter.println(), или
         - BufferedWriter.newLine()

Path:
Представлява път до файл или директория.
Осигурява гъвкавост при работа с пътища.
Files:
Предоставя удобни методи за операции с файлове и директории.
Улеснява общи задачи като проверка за съществуване, четене и писане.